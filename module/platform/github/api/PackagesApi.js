/**
 * GitHub v3 REST API
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import Package from '../model/Package';
import PackageVersion from '../model/PackageVersion';

/**
* Packages service.
* @module api/PackagesApi
* @version 1.1.4
*/
export default class PackagesApi {

    /**
    * Constructs a new PackagesApi. 
    * @alias module:api/PackagesApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the packagesDeletePackageForAuthenticatedUser operation.
     * @callback module:api/PackagesApi~packagesDeletePackageForAuthenticatedUserCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Delete a package for the authenticated user
     * Deletes a package owned by the authenticated user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, `repo` scope is also required. For the list these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {module:api/PackagesApi~packagesDeletePackageForAuthenticatedUserCallback} callback The callback function, accepting three arguments: error, data, response
     */
    packagesDeletePackageForAuthenticatedUser(packageType, packageName, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesDeletePackageForAuthenticatedUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesDeletePackageForAuthenticatedUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/user/packages/{package_type}/{package_name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesDeletePackageForOrg operation.
     * @callback module:api/PackagesApi~packagesDeletePackageForOrgCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Delete a package for an organization
     * Deletes an entire package in an organization. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  The authenticated user must have admin permissions in the organization to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {String} org The organization name. The name is not case sensitive.
     * @param {module:api/PackagesApi~packagesDeletePackageForOrgCallback} callback The callback function, accepting three arguments: error, data, response
     */
    packagesDeletePackageForOrg(packageType, packageName, org, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesDeletePackageForOrg");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesDeletePackageForOrg");
      }
      // verify the required parameter 'org' is set
      if (org === undefined || org === null) {
        throw new Error("Missing the required parameter 'org' when calling packagesDeletePackageForOrg");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'org': org
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/orgs/{org}/packages/{package_type}/{package_name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesDeletePackageForUser operation.
     * @callback module:api/PackagesApi~packagesDeletePackageForUserCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Delete a package for a user
     * Deletes an entire package for a user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {String} username The handle for the GitHub user account.
     * @param {module:api/PackagesApi~packagesDeletePackageForUserCallback} callback The callback function, accepting three arguments: error, data, response
     */
    packagesDeletePackageForUser(packageType, packageName, username, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesDeletePackageForUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesDeletePackageForUser");
      }
      // verify the required parameter 'username' is set
      if (username === undefined || username === null) {
        throw new Error("Missing the required parameter 'username' when calling packagesDeletePackageForUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'username': username
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/users/{username}/packages/{package_type}/{package_name}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesDeletePackageVersionForAuthenticatedUser operation.
     * @callback module:api/PackagesApi~packagesDeletePackageVersionForAuthenticatedUserCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Delete a package version for the authenticated user
     * Deletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  The authenticated user must have admin permissions in the organization to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {Number} packageVersionId Unique identifier of the package version.
     * @param {module:api/PackagesApi~packagesDeletePackageVersionForAuthenticatedUserCallback} callback The callback function, accepting three arguments: error, data, response
     */
    packagesDeletePackageVersionForAuthenticatedUser(packageType, packageName, packageVersionId, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesDeletePackageVersionForAuthenticatedUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesDeletePackageVersionForAuthenticatedUser");
      }
      // verify the required parameter 'packageVersionId' is set
      if (packageVersionId === undefined || packageVersionId === null) {
        throw new Error("Missing the required parameter 'packageVersionId' when calling packagesDeletePackageVersionForAuthenticatedUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'package_version_id': packageVersionId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/user/packages/{package_type}/{package_name}/versions/{package_version_id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesDeletePackageVersionForOrg operation.
     * @callback module:api/PackagesApi~packagesDeletePackageVersionForOrgCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Delete package version for an organization
     * Deletes a specific package version in an organization. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  The authenticated user must have admin permissions in the organization to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {String} org The organization name. The name is not case sensitive.
     * @param {Number} packageVersionId Unique identifier of the package version.
     * @param {module:api/PackagesApi~packagesDeletePackageVersionForOrgCallback} callback The callback function, accepting three arguments: error, data, response
     */
    packagesDeletePackageVersionForOrg(packageType, packageName, org, packageVersionId, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesDeletePackageVersionForOrg");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesDeletePackageVersionForOrg");
      }
      // verify the required parameter 'org' is set
      if (org === undefined || org === null) {
        throw new Error("Missing the required parameter 'org' when calling packagesDeletePackageVersionForOrg");
      }
      // verify the required parameter 'packageVersionId' is set
      if (packageVersionId === undefined || packageVersionId === null) {
        throw new Error("Missing the required parameter 'packageVersionId' when calling packagesDeletePackageVersionForOrg");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'org': org,
        'package_version_id': packageVersionId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesDeletePackageVersionForUser operation.
     * @callback module:api/PackagesApi~packagesDeletePackageVersionForUserCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Delete package version for a user
     * Deletes a specific package version for a user. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {String} username The handle for the GitHub user account.
     * @param {Number} packageVersionId Unique identifier of the package version.
     * @param {module:api/PackagesApi~packagesDeletePackageVersionForUserCallback} callback The callback function, accepting three arguments: error, data, response
     */
    packagesDeletePackageVersionForUser(packageType, packageName, username, packageVersionId, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesDeletePackageVersionForUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesDeletePackageVersionForUser");
      }
      // verify the required parameter 'username' is set
      if (username === undefined || username === null) {
        throw new Error("Missing the required parameter 'username' when calling packagesDeletePackageVersionForUser");
      }
      // verify the required parameter 'packageVersionId' is set
      if (packageVersionId === undefined || packageVersionId === null) {
        throw new Error("Missing the required parameter 'packageVersionId' when calling packagesDeletePackageVersionForUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'username': username,
        'package_version_id': packageVersionId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser operation.
     * @callback module:api/PackagesApi~packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/PackageVersion>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List package versions for a package owned by the authenticated user
     * Lists package versions for a package owned by the authenticated user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {Object} opts Optional parameters
     * @param {Number} [page = 1)] The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
     * @param {Number} [perPage = 30)] The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
     * @param {module:model/String} [state = 'active')] The state of the package, either active or deleted.
     * @param {module:api/PackagesApi~packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/PackageVersion>}
     */
    packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(packageType, packageName, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName
      };
      let queryParams = {
        'page': opts['page'],
        'per_page': opts['perPage'],
        'state': opts['state']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [PackageVersion];
      return this.apiClient.callApi(
        '/user/packages/{package_type}/{package_name}/versions', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesGetAllPackageVersionsForPackageOwnedByOrg operation.
     * @callback module:api/PackagesApi~packagesGetAllPackageVersionsForPackageOwnedByOrgCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/PackageVersion>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List package versions for a package owned by an organization
     * Lists package versions for a package owned by an organization.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint if the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {String} org The organization name. The name is not case sensitive.
     * @param {Object} opts Optional parameters
     * @param {Number} [page = 1)] The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
     * @param {Number} [perPage = 30)] The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
     * @param {module:model/String} [state = 'active')] The state of the package, either active or deleted.
     * @param {module:api/PackagesApi~packagesGetAllPackageVersionsForPackageOwnedByOrgCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/PackageVersion>}
     */
    packagesGetAllPackageVersionsForPackageOwnedByOrg(packageType, packageName, org, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesGetAllPackageVersionsForPackageOwnedByOrg");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesGetAllPackageVersionsForPackageOwnedByOrg");
      }
      // verify the required parameter 'org' is set
      if (org === undefined || org === null) {
        throw new Error("Missing the required parameter 'org' when calling packagesGetAllPackageVersionsForPackageOwnedByOrg");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'org': org
      };
      let queryParams = {
        'page': opts['page'],
        'per_page': opts['perPage'],
        'state': opts['state']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [PackageVersion];
      return this.apiClient.callApi(
        '/orgs/{org}/packages/{package_type}/{package_name}/versions', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesGetAllPackageVersionsForPackageOwnedByUser operation.
     * @callback module:api/PackagesApi~packagesGetAllPackageVersionsForPackageOwnedByUserCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/PackageVersion>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List package versions for a package owned by a user
     * Lists package versions for a public package owned by a specified user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {String} username The handle for the GitHub user account.
     * @param {module:api/PackagesApi~packagesGetAllPackageVersionsForPackageOwnedByUserCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/PackageVersion>}
     */
    packagesGetAllPackageVersionsForPackageOwnedByUser(packageType, packageName, username, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesGetAllPackageVersionsForPackageOwnedByUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesGetAllPackageVersionsForPackageOwnedByUser");
      }
      // verify the required parameter 'username' is set
      if (username === undefined || username === null) {
        throw new Error("Missing the required parameter 'username' when calling packagesGetAllPackageVersionsForPackageOwnedByUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'username': username
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [PackageVersion];
      return this.apiClient.callApi(
        '/users/{username}/packages/{package_type}/{package_name}/versions', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesGetPackageForAuthenticatedUser operation.
     * @callback module:api/PackagesApi~packagesGetPackageForAuthenticatedUserCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Package} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get a package for the authenticated user
     * Gets a specific package for a package owned by the authenticated user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {module:api/PackagesApi~packagesGetPackageForAuthenticatedUserCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Package}
     */
    packagesGetPackageForAuthenticatedUser(packageType, packageName, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesGetPackageForAuthenticatedUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesGetPackageForAuthenticatedUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Package;
      return this.apiClient.callApi(
        '/user/packages/{package_type}/{package_name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesGetPackageForOrganization operation.
     * @callback module:api/PackagesApi~packagesGetPackageForOrganizationCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Package} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get a package for an organization
     * Gets a specific package in an organization.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {String} org The organization name. The name is not case sensitive.
     * @param {module:api/PackagesApi~packagesGetPackageForOrganizationCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Package}
     */
    packagesGetPackageForOrganization(packageType, packageName, org, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesGetPackageForOrganization");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesGetPackageForOrganization");
      }
      // verify the required parameter 'org' is set
      if (org === undefined || org === null) {
        throw new Error("Missing the required parameter 'org' when calling packagesGetPackageForOrganization");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'org': org
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Package;
      return this.apiClient.callApi(
        '/orgs/{org}/packages/{package_type}/{package_name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesGetPackageForUser operation.
     * @callback module:api/PackagesApi~packagesGetPackageForUserCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Package} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get a package for a user
     * Gets a specific package metadata for a public package owned by a user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {String} username The handle for the GitHub user account.
     * @param {module:api/PackagesApi~packagesGetPackageForUserCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Package}
     */
    packagesGetPackageForUser(packageType, packageName, username, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesGetPackageForUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesGetPackageForUser");
      }
      // verify the required parameter 'username' is set
      if (username === undefined || username === null) {
        throw new Error("Missing the required parameter 'username' when calling packagesGetPackageForUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'username': username
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Package;
      return this.apiClient.callApi(
        '/users/{username}/packages/{package_type}/{package_name}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesGetPackageVersionForAuthenticatedUser operation.
     * @callback module:api/PackagesApi~packagesGetPackageVersionForAuthenticatedUserCallback
     * @param {String} error Error message, if any.
     * @param {module:model/PackageVersion} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get a package version for the authenticated user
     * Gets a specific package version for a package owned by the authenticated user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {Number} packageVersionId Unique identifier of the package version.
     * @param {module:api/PackagesApi~packagesGetPackageVersionForAuthenticatedUserCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/PackageVersion}
     */
    packagesGetPackageVersionForAuthenticatedUser(packageType, packageName, packageVersionId, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesGetPackageVersionForAuthenticatedUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesGetPackageVersionForAuthenticatedUser");
      }
      // verify the required parameter 'packageVersionId' is set
      if (packageVersionId === undefined || packageVersionId === null) {
        throw new Error("Missing the required parameter 'packageVersionId' when calling packagesGetPackageVersionForAuthenticatedUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'package_version_id': packageVersionId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PackageVersion;
      return this.apiClient.callApi(
        '/user/packages/{package_type}/{package_name}/versions/{package_version_id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesGetPackageVersionForOrganization operation.
     * @callback module:api/PackagesApi~packagesGetPackageVersionForOrganizationCallback
     * @param {String} error Error message, if any.
     * @param {module:model/PackageVersion} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get a package version for an organization
     * Gets a specific package version in an organization.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {String} org The organization name. The name is not case sensitive.
     * @param {Number} packageVersionId Unique identifier of the package version.
     * @param {module:api/PackagesApi~packagesGetPackageVersionForOrganizationCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/PackageVersion}
     */
    packagesGetPackageVersionForOrganization(packageType, packageName, org, packageVersionId, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesGetPackageVersionForOrganization");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesGetPackageVersionForOrganization");
      }
      // verify the required parameter 'org' is set
      if (org === undefined || org === null) {
        throw new Error("Missing the required parameter 'org' when calling packagesGetPackageVersionForOrganization");
      }
      // verify the required parameter 'packageVersionId' is set
      if (packageVersionId === undefined || packageVersionId === null) {
        throw new Error("Missing the required parameter 'packageVersionId' when calling packagesGetPackageVersionForOrganization");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'org': org,
        'package_version_id': packageVersionId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PackageVersion;
      return this.apiClient.callApi(
        '/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesGetPackageVersionForUser operation.
     * @callback module:api/PackagesApi~packagesGetPackageVersionForUserCallback
     * @param {String} error Error message, if any.
     * @param {module:model/PackageVersion} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get a package version for a user
     * Gets a specific package version for a public package owned by a specified user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {Number} packageVersionId Unique identifier of the package version.
     * @param {String} username The handle for the GitHub user account.
     * @param {module:api/PackagesApi~packagesGetPackageVersionForUserCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/PackageVersion}
     */
    packagesGetPackageVersionForUser(packageType, packageName, packageVersionId, username, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesGetPackageVersionForUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesGetPackageVersionForUser");
      }
      // verify the required parameter 'packageVersionId' is set
      if (packageVersionId === undefined || packageVersionId === null) {
        throw new Error("Missing the required parameter 'packageVersionId' when calling packagesGetPackageVersionForUser");
      }
      // verify the required parameter 'username' is set
      if (username === undefined || username === null) {
        throw new Error("Missing the required parameter 'username' when calling packagesGetPackageVersionForUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'package_version_id': packageVersionId,
        'username': username
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PackageVersion;
      return this.apiClient.callApi(
        '/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesListDockerMigrationConflictingPackagesForAuthenticatedUser operation.
     * @callback module:api/PackagesApi~packagesListDockerMigrationConflictingPackagesForAuthenticatedUserCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/Package>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get list of conflicting packages during Docker migration for authenticated-user
     * Lists all packages that are owned by the authenticated user within the user's namespace, and that encountered a conflict during a Docker migration.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint.
     * @param {module:api/PackagesApi~packagesListDockerMigrationConflictingPackagesForAuthenticatedUserCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/Package>}
     */
    packagesListDockerMigrationConflictingPackagesForAuthenticatedUser(callback) {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Package];
      return this.apiClient.callApi(
        '/user/docker/conflicts', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesListDockerMigrationConflictingPackagesForOrganization operation.
     * @callback module:api/PackagesApi~packagesListDockerMigrationConflictingPackagesForOrganizationCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/Package>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get list of conflicting packages during Docker migration for organization
     * Lists all packages that are in a specific organization, are readable by the requesting user, and that encountered a conflict during a Docker migration.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint.
     * @param {String} org The organization name. The name is not case sensitive.
     * @param {module:api/PackagesApi~packagesListDockerMigrationConflictingPackagesForOrganizationCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/Package>}
     */
    packagesListDockerMigrationConflictingPackagesForOrganization(org, callback) {
      let postBody = null;
      // verify the required parameter 'org' is set
      if (org === undefined || org === null) {
        throw new Error("Missing the required parameter 'org' when calling packagesListDockerMigrationConflictingPackagesForOrganization");
      }

      let pathParams = {
        'org': org
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Package];
      return this.apiClient.callApi(
        '/orgs/{org}/docker/conflicts', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesListDockerMigrationConflictingPackagesForUser operation.
     * @callback module:api/PackagesApi~packagesListDockerMigrationConflictingPackagesForUserCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/Package>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get list of conflicting packages during Docker migration for user
     * Lists all packages that are in a specific user's namespace, that the requesting user has access to, and that encountered a conflict during Docker migration.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint.
     * @param {String} username The handle for the GitHub user account.
     * @param {module:api/PackagesApi~packagesListDockerMigrationConflictingPackagesForUserCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/Package>}
     */
    packagesListDockerMigrationConflictingPackagesForUser(username, callback) {
      let postBody = null;
      // verify the required parameter 'username' is set
      if (username === undefined || username === null) {
        throw new Error("Missing the required parameter 'username' when calling packagesListDockerMigrationConflictingPackagesForUser");
      }

      let pathParams = {
        'username': username
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Package];
      return this.apiClient.callApi(
        '/users/{username}/docker/conflicts', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesListPackagesForAuthenticatedUser operation.
     * @callback module:api/PackagesApi~packagesListPackagesForAuthenticatedUserCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/Package>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List packages for the authenticated user's namespace
     * Lists packages owned by the authenticated user within the user's namespace.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} [visibility] The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`. For the list of GitHub Packages registries that support granular permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"
     * @param {Number} [page = 1)] The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
     * @param {Number} [perPage = 30)] The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
     * @param {module:api/PackagesApi~packagesListPackagesForAuthenticatedUserCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/Package>}
     */
    packagesListPackagesForAuthenticatedUser(packageType, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesListPackagesForAuthenticatedUser");
      }

      let pathParams = {
      };
      let queryParams = {
        'package_type': packageType,
        'visibility': opts['visibility'],
        'page': opts['page'],
        'per_page': opts['perPage']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Package];
      return this.apiClient.callApi(
        '/user/packages', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesListPackagesForOrganization operation.
     * @callback module:api/PackagesApi~packagesListPackagesForOrganizationCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/Package>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List packages for an organization
     * Lists packages in an organization readable by the user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} org The organization name. The name is not case sensitive.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} [visibility] The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`. For the list of GitHub Packages registries that support granular permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"
     * @param {Number} [page = 1)] The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
     * @param {Number} [perPage = 30)] The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
     * @param {module:api/PackagesApi~packagesListPackagesForOrganizationCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/Package>}
     */
    packagesListPackagesForOrganization(packageType, org, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesListPackagesForOrganization");
      }
      // verify the required parameter 'org' is set
      if (org === undefined || org === null) {
        throw new Error("Missing the required parameter 'org' when calling packagesListPackagesForOrganization");
      }

      let pathParams = {
        'org': org
      };
      let queryParams = {
        'package_type': packageType,
        'visibility': opts['visibility'],
        'page': opts['page'],
        'per_page': opts['perPage']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Package];
      return this.apiClient.callApi(
        '/orgs/{org}/packages', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesListPackagesForUser operation.
     * @callback module:api/PackagesApi~packagesListPackagesForUserCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/Package>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List packages for a user
     * Lists all packages in a user's namespace for which the requesting user has access.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} username The handle for the GitHub user account.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} [visibility] The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`. For the list of GitHub Packages registries that support granular permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"
     * @param {Number} [page = 1)] The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
     * @param {Number} [perPage = 30)] The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
     * @param {module:api/PackagesApi~packagesListPackagesForUserCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/Package>}
     */
    packagesListPackagesForUser(packageType, username, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesListPackagesForUser");
      }
      // verify the required parameter 'username' is set
      if (username === undefined || username === null) {
        throw new Error("Missing the required parameter 'username' when calling packagesListPackagesForUser");
      }

      let pathParams = {
        'username': username
      };
      let queryParams = {
        'package_type': packageType,
        'visibility': opts['visibility'],
        'page': opts['page'],
        'per_page': opts['perPage']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Package];
      return this.apiClient.callApi(
        '/users/{username}/packages', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesRestorePackageForAuthenticatedUser operation.
     * @callback module:api/PackagesApi~packagesRestorePackageForAuthenticatedUserCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Restore a package for the authenticated user
     * Restores a package owned by the authenticated user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {Object} opts Optional parameters
     * @param {String} [token] package token
     * @param {module:api/PackagesApi~packagesRestorePackageForAuthenticatedUserCallback} callback The callback function, accepting three arguments: error, data, response
     */
    packagesRestorePackageForAuthenticatedUser(packageType, packageName, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesRestorePackageForAuthenticatedUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesRestorePackageForAuthenticatedUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName
      };
      let queryParams = {
        'token': opts['token']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/user/packages/{package_type}/{package_name}/restore', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesRestorePackageForOrg operation.
     * @callback module:api/PackagesApi~packagesRestorePackageForOrgCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Restore a package for an organization
     * Restores an entire package in an organization.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.  The authenticated user must have admin permissions in the organization to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {String} org The organization name. The name is not case sensitive.
     * @param {Object} opts Optional parameters
     * @param {String} [token] package token
     * @param {module:api/PackagesApi~packagesRestorePackageForOrgCallback} callback The callback function, accepting three arguments: error, data, response
     */
    packagesRestorePackageForOrg(packageType, packageName, org, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesRestorePackageForOrg");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesRestorePackageForOrg");
      }
      // verify the required parameter 'org' is set
      if (org === undefined || org === null) {
        throw new Error("Missing the required parameter 'org' when calling packagesRestorePackageForOrg");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'org': org
      };
      let queryParams = {
        'token': opts['token']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/orgs/{org}/packages/{package_type}/{package_name}/restore', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesRestorePackageForUser operation.
     * @callback module:api/PackagesApi~packagesRestorePackageForUserCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Restore a package for a user
     * Restores an entire package for a user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.  If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {String} username The handle for the GitHub user account.
     * @param {Object} opts Optional parameters
     * @param {String} [token] package token
     * @param {module:api/PackagesApi~packagesRestorePackageForUserCallback} callback The callback function, accepting three arguments: error, data, response
     */
    packagesRestorePackageForUser(packageType, packageName, username, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesRestorePackageForUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesRestorePackageForUser");
      }
      // verify the required parameter 'username' is set
      if (username === undefined || username === null) {
        throw new Error("Missing the required parameter 'username' when calling packagesRestorePackageForUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'username': username
      };
      let queryParams = {
        'token': opts['token']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/users/{username}/packages/{package_type}/{package_name}/restore', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesRestorePackageVersionForAuthenticatedUser operation.
     * @callback module:api/PackagesApi~packagesRestorePackageVersionForAuthenticatedUserCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Restore a package version for the authenticated user
     * Restores a package version owned by the authenticated user.  You can restore a deleted package version under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {Number} packageVersionId Unique identifier of the package version.
     * @param {module:api/PackagesApi~packagesRestorePackageVersionForAuthenticatedUserCallback} callback The callback function, accepting three arguments: error, data, response
     */
    packagesRestorePackageVersionForAuthenticatedUser(packageType, packageName, packageVersionId, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesRestorePackageVersionForAuthenticatedUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesRestorePackageVersionForAuthenticatedUser");
      }
      // verify the required parameter 'packageVersionId' is set
      if (packageVersionId === undefined || packageVersionId === null) {
        throw new Error("Missing the required parameter 'packageVersionId' when calling packagesRestorePackageVersionForAuthenticatedUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'package_version_id': packageVersionId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesRestorePackageVersionForOrg operation.
     * @callback module:api/PackagesApi~packagesRestorePackageVersionForOrgCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Restore package version for an organization
     * Restores a specific package version in an organization.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.  The authenticated user must have admin permissions in the organization to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {String} org The organization name. The name is not case sensitive.
     * @param {Number} packageVersionId Unique identifier of the package version.
     * @param {module:api/PackagesApi~packagesRestorePackageVersionForOrgCallback} callback The callback function, accepting three arguments: error, data, response
     */
    packagesRestorePackageVersionForOrg(packageType, packageName, org, packageVersionId, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesRestorePackageVersionForOrg");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesRestorePackageVersionForOrg");
      }
      // verify the required parameter 'org' is set
      if (org === undefined || org === null) {
        throw new Error("Missing the required parameter 'org' when calling packagesRestorePackageVersionForOrg");
      }
      // verify the required parameter 'packageVersionId' is set
      if (packageVersionId === undefined || packageVersionId === null) {
        throw new Error("Missing the required parameter 'packageVersionId' when calling packagesRestorePackageVersionForOrg");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'org': org,
        'package_version_id': packageVersionId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the packagesRestorePackageVersionForUser operation.
     * @callback module:api/PackagesApi~packagesRestorePackageVersionForUserCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Restore package version for a user
     * Restores a specific package version for a user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.  If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
     * @param {module:model/String} packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * @param {String} packageName The name of the package.
     * @param {String} username The handle for the GitHub user account.
     * @param {Number} packageVersionId Unique identifier of the package version.
     * @param {module:api/PackagesApi~packagesRestorePackageVersionForUserCallback} callback The callback function, accepting three arguments: error, data, response
     */
    packagesRestorePackageVersionForUser(packageType, packageName, username, packageVersionId, callback) {
      let postBody = null;
      // verify the required parameter 'packageType' is set
      if (packageType === undefined || packageType === null) {
        throw new Error("Missing the required parameter 'packageType' when calling packagesRestorePackageVersionForUser");
      }
      // verify the required parameter 'packageName' is set
      if (packageName === undefined || packageName === null) {
        throw new Error("Missing the required parameter 'packageName' when calling packagesRestorePackageVersionForUser");
      }
      // verify the required parameter 'username' is set
      if (username === undefined || username === null) {
        throw new Error("Missing the required parameter 'username' when calling packagesRestorePackageVersionForUser");
      }
      // verify the required parameter 'packageVersionId' is set
      if (packageVersionId === undefined || packageVersionId === null) {
        throw new Error("Missing the required parameter 'packageVersionId' when calling packagesRestorePackageVersionForUser");
      }

      let pathParams = {
        'package_type': packageType,
        'package_name': packageName,
        'username': username,
        'package_version_id': packageVersionId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
